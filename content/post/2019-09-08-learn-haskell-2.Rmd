---
title: Learn Haskell 2
author: ''
date: '2019-09-08'
slug: learn-haskell-2
categories:
  - functional programming
  - programming
tags:
  - Functional Programming
---

```{r echo=FALSE}
knitr::opts_chunk$set(comment="##", engine.path='/Users/duliu/.ghcup/bin/ghc')
```


It makes sense that if some pattern/idea is used a lot, then it should be denoted with minial syntax. It follows that Haskell, famous for being functional, doesn't even have a keyword for defining functions. To define a function, start with function name (`add` for example), follow by argument list separated by spaces, followed by `=` and then the function body:

```{haskell c1}
add x y = x + y
print $ add 1 2
```

Note that the `$` sign seperate `print` and `add` so the compiler knows `add` is not an argument to `print`.


Functions are automatically curried, meaning that we can pass in fewer arguments and get back a more specific function. 

For example, if we want to define a function that adds 2 to a number, we can do: `add2 = add 2`. That is, the type of `add` is `Int -> Int -> Int`, or in English, `add` takes an `Int` and returns _a function that takes an `Int` and returns an `Int`_. I use `Int` as a concrete example, actually the `add` we defined is polymophic in that it can also operate on `Double`, `Float` etc.

```{haskell c2}
add x y = x + y
add2 = add 2
print $ add2 3
```


Functions support pattern matching. For example, to calculate the distance to origin of a point, (3, 4), we can do

```{haskell c3}
point = (3, 4)
distToOrigin (x, y) = sqrt $ x^2 + y^2
distToOrigin point
```

Function composition is denoted by `.` (pronouned as "after"). For example, we can compose `sqrt` and `distToOriginSquared` to compute distance to origin:

```{haskell c4}
point = (6, 8)
distToOriginSquared (x, y) = x^2 + y^2
distToOrigin = sqrt . distToOriginSquared
distToOrigin point
```

